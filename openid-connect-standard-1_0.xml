<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml.resource.org/authoring/rfc2629.dtd">
<rfc category="exp" docName="openid-connect-standard-1_0" ipr="trust200902">
  <?rfc toc="yes" ?>

  <?rfc tocdepth="3" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc strict="yes" ?>

  <?rfc iprnotified="no" ?>

  <?rfc private="Draft" ?>

  <front>
    <title>OpenID Connect Standard 1.0 - draft 04</title>

    <author fullname="Nat Sakimura" initials="N." role="editor"
            surname="Sakimura">
      <organization abbrev="NRI">Nomura Research Institute,
      Ltd.</organization>

      <address>
        <email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Protiviti">Protiviti Government
      Services</organization>

      <address>
        <email>jbradley@mac.com</email>
      </address>
    </author>

    <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
      <organization abbrev="Google">Google</organization>

      <address>
        <email>breno@google.com</email>
      </address>
    </author>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft Corporation</organization>

      <address>
        <email>mbj@microsoft.com</email>
      </address>
    </author>

    <author fullname="Edmund Jay" initials="E." surname="Jay">
      <organization abbrev="MGI1">MGI1</organization>

      <address>
        <email>ejay@mgi1.com</email>
      </address>
    </author>

    <date day="2" month="September" year="2011" />

    <abstract>
      <t>OpenID Connect 1.0 is a simple identity layer on top of OAuth
      2.0 protocol. It allows a web site or application to verify the
      identity of the user based on the authentication performed by
      the authorization server, as well as to obtain basic profile information
      about the user in an interoperable and RESTful manner.</t>

      <t>OpenID Connect Standard 1.0 is an HTTP protocol binding for
      OpenID Connect Messages 1.0 request and response messages.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="rnc" title="Requirements Notation and Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"></xref> .</t>

      <t>Throughout this document, values are quoted to indicate that they are
      to be taken literally. When using these values in protocol messages, the
      quotes MUST NOT be used as part of the value.</t>
    </section>

    <section anchor="terminology" title="Terminology">
      <t>Followings are the additional terminology defined in this
      specification in addition to those defined in <xref
      target="OpenID.Messages">OpenID Connect Messages 1.0</xref> and <xref
      target="OAuth.2.0">OAuth 2.0</xref>.</t>

      <t><list style="hanging">
          <t hangText="Artifact">A small string that acts as a reference to
          the larger body of data.</t>

          <t hangText="Request File">A JSON structure that captures the <xref
          target="OpenID.Messages">OpenID Connect Messages 1.0</xref>
          Authorization Request parameters that can be pointed by a URL that
          is reachable by the Authorization Server.</t>

          <t hangText="Request URI">A URL that points to the Request File. It
          MUST be accessible by the Authorization Server.</t>

          <t hangText="Request Registration Endpoint">An HTTPS Endpoint URL
          provided by the Authorization Server so that the Client MAY register
          the Request File to obtain the Request URI.</t>
        </list></t>
    </section>

    <section title="HTTP Protocol Binding">
      <t>The <xref target="RFC2616">HTTP</xref> protocol is a widely used
      application level protocol for distribute, collaborative, hypermedia
      systems. It's ubiquitousness makes it an ideal protocol for use by
      OpenID Connect. This specification describes the binding of the HTTP
      protocol with the various endpoints described in <xref
      target="OpenID.Messages"> OpenID Connect Messages</xref>.</t>
    </section>

    <section title="Authorization Endpoint">
      <t>Authorization requests follow two paths, the authorization code flow
      and the implicit grant flow. The authorization code flow is suitable for
      clients that can securely maintain client secrets between itself and the
      authorization server whereas the implicit grant flow is suitable for
      clients that cannot.</t>

      <section anchor="code_flow" title="Authorization Code Flow">
        <t>The authorization code protocol flow goes through the following
        steps.</t>

        <t><list style="numbers">
            <t>Client prepares an Authorization Request containing the desired
            request parameters.</t>

            <t>Client sends a request to the Authorization Server.</t>

            <t>Authorization Server Authenticates the End-User</t>

            <t>Authorization Server Obtains the End-User
            Consent/Authorization</t>

            <t>Authorization Server Sends the End-User back to the Client with
            an Authorization Code</t>

            <t>Client requests Assertion using the Authorization Code</t>

            <t>Client receives Assertion in the response body</t>

            <t>(OPTIONAL) Client accesses the <xref
            target="userinfo_ep">UserInfo endpoint </xref></t>

            <t>(OPTIONAL) Client receives UserInfo Response</t>
          </list>Note that in each step, the party that receives message MUST
        verify it according to the verification rule set in <xref
        target="OpenID.Messages">OpenID Connect Messages 1.0</xref>.</t>

        <section anchor="rf_prep"
                 title="Client prepares an Authorization Request">
          <t>When the user wishes to access a Protected Resource, and the
          End-User Authorization has not yet been obtained, the Client
          prepares an Authorization Request to the authorization endpoint.</t>

          <t>The scheme used in the Authorization URL MUST be HTTPS.</t>

          <t>This binding further constrains the following request
          parameters</t>

          <t><list style="hanging">
              <t hangText="response_type">It MUST include <spanx style="verb">code</spanx>
              and <spanx style="verb">id_token</spanx>.</t>
            </list></t>

          <t>Other required parameters in the request include the
          following:</t>

          <t><list style="hanging">
              <t hangText="client_id">The client identifier.</t>

              <t hangText="scope">It MUST include <spanx style="verb">openid</spanx>
              as one of the strings. Other values that MAY be included are
              <spanx style="verb">profile</spanx>, <spanx style="verb">email</spanx>,
              <spanx style="verb">address</spanx>, and <spanx style="verb">PPID</spanx>.
              The values specify an additive list of claims that are returned
              by the UserInfo endpoint.</t>

              <t hangText="redirect_uri">A redirection URI where the response
              will be sent.</t>
            </list></t>

          <t>The request can contain the following optional parameters:</t>

          <t><list style="hanging">
              <t hangText="state">An opaque value used to maintain state
              between the request and the callback.</t>

              <t hangText="request">A <xref target="JWT">JWT</xref> encoded
              <eref
              target="http://openid.net/specs/openid-connect-framework-1_0.html#OpenIDReq">OpenID
              Request Object</eref>.</t>

              <t hangText="request_uri">A URL that points to an <eref
              target="http://openid.net/specs/openid-connect-framework-1_0.html#OpenIDReq">OpenID
              Request Object</eref>.</t>

              <t hangText="display">A string value that can be <spanx
              style="verb">none</spanx>, <spanx style="verb">popup</spanx>, or
              <spanx style="verb">mobile</spanx>. Refer to <xref
              target="OpenID.Messages">OpenID Connect Messages 1.0</xref> for
              more information.</t>

              <t hangText="prompt">A space delimited list that can contain
              <spanx style="verb">login</spanx>, <spanx style="verb">consent</spanx>,
              and <spanx style="verb">select_account</spanx>. Refer to <xref
              target="OpenID.Messages">OpenID Connect Messages 1.0</xref> for
              more information</t>

              <t hangText="nonce">A random, unique string value.</t>

              <t hangText="audience">The identifier of the target audience for
              an ID token.</t>
            </list></t>

          <t>There are three methods to send the request to the authorization
          endpoint: a) query parameters method b) request parameter method,
          and c) request file method.</t>

          <t>The query parameters method is used in simple cases when default
          UserInfo and ID Token claims are desired and requests and responses
          do not need to be signed or encrypted.</t>

          <t>The request parameter method is used by sending an OpenID Request
          Object when the client desires to retrieve a different set of
          UserInfo and ID Token claims. The request parameter method also
          allows requests and responses to be signed or encrypted. </t>

          <t>The request file method works similar to the request parameter
          method but differs in that it sends an URL as a reference to the
          OpenID Request Object. It enables large requests to be sent
          securely and compactly even on browsers with limited capabilities.
          Clients SHOULD use the request file method to minimize the request
          size.</t>

          <t>Authorization servers MUST support the use of the HTTP "GET"
          method as define in <xref target="RFC2616">RFC 2616</xref> and MAY
          support the "POST" method at the authorization endpoint.</t>

          <t>If using the HTTP "GET" method, the parameters are serialized
          using URI query string serialization as defined in <xref
          target="OpenID.Messages">OpenID Connect Messages 1.0</xref>. If
          using the HTTP "POST" method, the request parameters are added to
          the HTTP request entity-body using
          "application/x-www-form-urlencoded" format.</t>

          <section title="Query Parameters Method">
            <t>The Client prepares an Authorization Request to the
            Authorization endpoint using the appropriate parameters with <eref
            target="http://openid.net/specs/openid-connect-messages-1_0.html#qss">HTTP
            query string serialization</eref>.</t>

            <t><figure>
                <preamble>The following is a non-normative example of an
                Authorization Request URL. Note that the line wraps within the
                values are for display purpose only:</preamble>

                <artwork><![CDATA[https://server.example.com/op/authorize?
response_type=code%20id_token
&client_id=s6BhdRkqt3
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&scope=openid
&state=af0ifjsldkj]]></artwork>
              </figure></t>

            <section anchor="norm_req"
                     title="Client sends a request to the Authorization Server">
              <t>Having constructed the URL, the client sends the End-User to
              the HTTPS End-User Authorization Endpoint using the URL. This
              MAY happen via HTTPS redirect, hyperlinking, or any other means
              of directing the User-Agent to the URL.</t>

              <t>The Client SHOULD send the request using the HTTPS GET
              method, but MAY send it via the HTTPS POST if the authorization
              server supports it as defined in <xref
              target="W3C.REC-html401-19991224"></xref></t>

              <t>Following is a non-normative example using HTTP redirect.
              Note: Line wraps are for display purpose only.</t>

              <figure>
                <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://server.example.com/authorize?
response_type=code%20id_token
&client_id=s6BhdRkqt3
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&scope=openid
&state=af0ifjsldkj
]]></artwork>
              </figure>
            </section>
          </section>

          <section title="Request Parameter Method">
            <t>The Client prepares an Authorization Request to the
            Authorization endpoint using the appropriate HTTP parameters
            serialization. The request parameters MUST include the <spanx
            style="verb">request</spanx> parameter defined in the <xref
            target="rf_prep">Client Prepares an Authorization Request</xref>
            section. The <spanx style="verb">request</spanx> parameter is a
            <xref target="JWT">JWT</xref> encoded <eref
            target="http://openid.net/specs/openid-connect-framework-1_0.html#OpenIDReq">OpenID
            Request Object</eref> which specifies the content and format of
            the response returned from the UserInfo endpoint and ID Token
            endpoint. The JWT object MAY be signed or signed and encrypted via
            <xref target="JWS">JWS</xref> and <xref target="JWE">JWE</xref>
            respectively, thereby providing authentication, integrity,
            non-repudiation and/or confidentiality.</t>

            <t>Request parameters in the <eref
            target="http://openid.net/specs/openid-connect-framework-1_0.html#OpenIDReq">OpenID
            Request Object</eref> takes precedence over query parameters.</t>

            <t><figure>
                <preamble>The following is a non-normative example of an
                OpenID Request Object. Note that the line wraps within the
                values are for display purpose only:</preamble>

                <artwork><![CDATA[{
 "response_type": "code id_token",
 "client_id": "s6BhdRkqt3",
 "redirect_uri": "https://client.example.com/cb",
 "scope": "openid profile",
 "state": "af0ifjsldkj",
 "userinfo":
   {
     "claims":
       {
         "name": null,
         "nickname": {"optional": true},
         "email": null,
         "verified": null,
         "picture": {"optional": true},
       },
     "format": "signed"
   }
 "id_token":
   {
     "max_age": 86400,
     "iso29115": "2"
   }
}]]></artwork>
              </figure> <figure>
                <preamble>The following is a non-normative example of a <xref
                target="JWT">JWT</xref> encoded OpenID Request Object. Note
                that the line wraps within the values are for display purpose
                only:</preamble>

                <artwork><![CDATA[
JWT algorithm = HS256
HMAC HASH Key = 'aaa'

JSON Encoded Header = "{"alg":"HS256","typ":"JWT"}"
JSON Encoded Payload =  "{"response_type":"code id_token","client_id":"s6BhdRkqt3",
                          "redirect_uri":"https:\/\/client.example.com\/cb","scope":"openid profile","state":"af0ifjsldkj",
                          "userinfo":{"claims":{"name":null,"nickname":{"optional":true},"email":null,"verified":null,
                                                "picture":{"optional":true}},"format":"signed"},
                          "id_token":{"max_age":86400,"iso29115":"2"}}"

JWT =  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyZXNwb25zZV90eXBlIjoiY29kZSBpZF90b2tlbiIsImNsaWVudF9pZCI6InM2QmhkUmtx
       dDMiLCJyZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY2xpZW50LmV4YW1wbGUuY29tXC9jYiIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUiLCJzd
       GF0ZSI6ImFmMGlmanNsZGtqIiwidXNlcmluZm8iOnsiY2xhaW1zIjp7Im5hbWUiOm51bGwsIm5pY2tuYW1lIjp7Im9wdGlvbmFsIjp0cnVlfS
       wiZW1haWwiOm51bGwsInZlcmlmaWVkIjpudWxsLCJwaWN0dXJlIjp7Im9wdGlvbmFsIjp0cnVlfX0sImZvcm1hdCI6InNpZ25lZCJ9LCJpZF9
       0b2tlbiI6eyJtYXhfYWdlIjo4NjQwMCwiaXNvMjkxMTUiOiIyIn19.2OiqRgrbrHkA1FZ5p_7bc_RSdTbH-wo_Agk-ZRpD3wY
]]></artwork>
              </figure></t>

            <t><figure>
                <preamble>The following is a non-normative example of an
                Authorization Request URL. Note that the line wraps within the
                values are for display purpose only:</preamble>

                <artwork><![CDATA[https://server.example.com/authorize?
response_type=code%02id_token
&client_id=s6BhdRkqt3
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&scope=openid
&state=af0ifjsldkj
&request=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyZXNwb25zZV90eXBlIjoiY29kZSBpZF90b2tlbiIsImNsaWVudF9pZCI6InM2QmhkUmtx
dDMiLCJyZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY2xpZW50LmV4YW1wbGUuY29tXC9jYiIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUiLCJzd
GF0ZSI6ImFmMGlmanNsZGtqIiwidXNlcmluZm8iOnsiY2xhaW1zIjp7Im5hbWUiOm51bGwsIm5pY2tuYW1lIjp7Im9wdGlvbmFsIjp0cnVlfS
wiZW1haWwiOm51bGwsInZlcmlmaWVkIjpudWxsLCJwaWN0dXJlIjp7Im9wdGlvbmFsIjp0cnVlfX0sImZvcm1hdCI6InNpZ25lZCJ9LCJpZF9
0b2tlbiI6eyJtYXhfYWdlIjo4NjQwMCwiaXNvMjkxMTUiOiIyIn19.2OiqRgrbrHkA1FZ5p_7bc_RSdTbH-wo_Agk-ZRpD3wY]]></artwork>
              </figure></t>

            <section anchor="request_req"
                     title="Client Sends a Request to the Authorization Server">
              <t>Having constructed the URL, the client sends the End-User to
              the HTTPS End-User Authorization Endpoint using the URL. This
              MAY happen via HTTPS redirect, hyperlinking, or any other means
              of directing the User-Agent to the URL.</t>

              <t>The Client MAY send the request using the HTTP GET method,
              but MUST send it via the HTTP POST if the authorization server
              supports it as defined in <xref
              target="W3C.REC-html401-19991224"></xref></t>

              <t>Following is a non-normative example using HTTP redirect.
              Note: Line wraps are for display purpose only.</t>

              <figure>
                <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://server.example.com/authorize?
response_type=code%20id_token
&client_id=s6BhdRkqt3
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&scope=openid
&state=af0ifjsldkj
&request=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyZXNwb25zZV90eXBlIjoiY29kZSBpZF90b2tlbiIsImNsaWVudF9pZCI6InM2QmhkUmtx
dDMiLCJyZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY2xpZW50LmV4YW1wbGUuY29tXC9jYiIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUiLCJzd
GF0ZSI6ImFmMGlmanNsZGtqIiwidXNlcmluZm8iOnsiY2xhaW1zIjp7Im5hbWUiOm51bGwsIm5pY2tuYW1lIjp7Im9wdGlvbmFsIjp0cnVlfS
wiZW1haWwiOm51bGwsInZlcmlmaWVkIjpudWxsLCJwaWN0dXJlIjp7Im9wdGlvbmFsIjp0cnVlfX0sImZvcm1hdCI6InNpZ25lZCJ9LCJpZF9
0b2tlbiI6eyJtYXhfYWdlIjo4NjQwMCwiaXNvMjkxMTUiOiIyIn19.2OiqRgrbrHkA1FZ5p_7bc_RSdTbH-wo_Agk-ZRpD3wY
]]></artwork>
              </figure>
            </section>
          </section>

          <section title="Request File Method">
            <t>The request file method differs from the other methods in that
            it uses a request file which contains all the authorization
            request parameters. It sends the request file URL to the
            authorization endpoint instead of the request parameters.</t>

            <t>The Client prepares a file with a JSON serialized Authorization
            Request described in <xref target="OpenID.Messages">OpenID Connect
            Messages 1.0</xref> with a globally reachable URL. Optionally, the
            request may contain other extension parameters. It MAY be signed
            or signed and encrypted via <xref target="JWS">JWS</xref> and
            <xref target="JWE">JWE</xref> respectively, thereby providing
            authentication, integrity, non-repudiation and/or
            confidentiality.</t>

            <t><figure>
                <preamble>Following is a non-normative example of a Request
                File. Note that the line wraps within the values are for
                display purpose only:</preamble>

                <artwork><![CDATA[{
    "response_type": "code id_token",
    "client_id": "s6BhdRkqt3",
    "redirect_uri": "https://client.example.com/cb",
    "scope": "openid",
    "state": "af0ifjsldkj"
}]]></artwork>
              </figure></t>

            <section anchor="rurl_create"
                     title="Client Obtains the URL of the Request File">
              <t>The Client then records the Request File either locally or
              remotely and obtains the Request URI, <spanx style="verb">"request_uri"</spanx>.</t>

              <t>Optionally, the Authorization Server may provide the Request
              File registration service at the Request Registration Endpoint,
              which allows the Client to register the Request File and obtain
              the URL for it in exchange. This is especially useful for the
              cases when the RP is behind the firewall or lives on a client
              device that cannot be accessed from the Authorization
              Server.</t>
            </section>

            <section anchor="art_req"
                     title="Client Sends a Request to Authorization Server via HTTPS Redirect">
              <t>The Client sends the user to the HTTPS End-User Authorization
              Endpoint through the HTTP 302 redirect with the following
              parameters</t>

              <t><list style="hanging">
                  <t hangText="response_type">REQUIRED. <spanx style="verb">"code".</spanx></t>

                  <t hangText="client_id">REQUIRED. The Client Identifier.</t>

                  <t hangText="request_uri">REQUIRED. The Request URI.</t>

                  <t hangText="state">OPTIONAL. An opaque value used by the
                  Client to maintain state between the request and callback.
                  If provided, the Authorization Server MUST include this
                  value when redirecting the user-agent back to the Client.
                  Clients are strongly advised to use this variable to relate
                  the request and response.</t>
                </list></t>

              <t>The entire URL MUST NOT exceed 512 bytes.</t>

              <t>The Client SHOULD send the request using the HTTP GET method,
              but MAY send it via the HTTP POST if the authorization server
              supports it as defined in <xref
              target="W3C.REC-html401-19991224"></xref></t>

              <figure>
                <preamble>Following is a non-normative example. Note: Line
                wraps are for display purpose only:</preamble>

                <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://server.example.com/authorize?response_type=code%20id_token&cliend_id=s6BhdRkqt3
&request_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Frf%2Ejs
&state=af0ifjsldkj]]></artwork>
              </figure>
            </section>

            <section title="Authorization Server Fetches the Request File">
              <t>Upon receipt of the Request, the Authorization Server MUST
              send a GET request to the <spanx style="verb">request_uri</spanx>
              to retrieve the content unless it is already cached and parse it
              to recreate the authorization request parameters.</t>

              <figure>
                <preamble>Following is a non-normative example of this fetch
                process. Note: Line wraps are for display purpose
                only:</preamble>

                <artwork><![CDATA[GET /rf.js HTTP/1.1
Host: client.example.com]]></artwork>
              </figure>
            </section>
          </section>
        </section>

        <section title="Authorization Server Authenticates the End-User">
          <t>The Authorization Server validates the request to ensure all
          required parameters are present and valid. If the request is valid,
          the authorization server MUST authenticate the End-User. The way in
          which the authorization server authenticates the End-User (e.g.
          username and password login, session cookies) is beyond the scope of
          this specification. An authentication user interface MAY be displayed
          by the Authorization Server depending on the authentication method
          used.</t>

          <t>The Authorization Server MUST attempt to authenticate the 
          user in the following cases:
          <list style="symbols">
                <t>The End-User is not already authenticated by the Authorization
                Server.</t>

                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with a value "login". The
                Authorization Server MUST reauthenticate the user
                even if the user is already authenticated.</t>
          </list></t>
          <t>The Authorization Server MUST NOT attempt authentication
          in the following cases:
          <list style="symbols">
                <t>The Authorization Request contains the <spanx 
                style="verb">"display"</spanx> parameter with a value "none".
                The Authorization Server MUST return an error if the user is 
                unauthenticated.</t>
          </list></t>
        </section>

        <section title="Authorization Server Obtains the End-User Consent/Authorization">
          <t>Once the user is authenticated, the Authorization Server MUST
          obtain an authorization decision. This MAY be done by presenting the
          user with a dialogue that allows the user to recognize what he is
          consenting to and obtain his consent or by establishing approval via
          other means (for example, via previous administrative approval).</t>

          <t>The Authorization Server MUST attempt to request authorization
          from the user in the following cases:
          <list style="symbols">
                <t>The End-User has not pre-authorized the client for the
                authorization request.</t>

                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with a value "consent". The
                Authorization Server MUST request user authorization even if the
                user has previously authorized the client.</t>
          </list></t>
          <t>The Authorization Server MUST NOT request user authorization in the
          following cases:
          <list style="symbols">
                <t>The Authorization Request contains the <spanx 
                style="verb">"display"</spanx> parameter with a value "none".
                The Authorization Server MUST return an error if the user has
                not pre-authorized the client.</t>
          </list></t>
        </section>

        <section anchor="art_res"
                 title="Authorization Server Sends the End-User Back to the Client ">
          <t>Once the authorization is determined, the Authorization Server
          returns a positive or negative response.</t>

          <section anchor="art_res_ok" title="End-User Grants Authorization">
            <t>If the resource owner grants the access request, the
            authorization server issues an Authorization code and delivers it
            to the client by adding the following parameters to the query
            component of the redirection URI using the
            "application/x-www-form-urlencoded" format:<list style="hanging">
                <t hangText="code">REQUIRED. The Authorization Code.</t>

                <t hangText="state">REQUIRED if the <spanx style="verb">"state"</spanx>
                parameter in the request. Set to the exact value of the <spanx
                style="verb">"state"</spanx> parameter received from the
                client.</t>
              </list></t>

            <t>No other parameter SHOULD be returned. The entire URL MUST NOT
            exceed 512 bytes.</t>

            <figure>
              <preamble>The following is a non-normative example. Line wraps
              after the second line is for the display purpose
              only:</preamble>

              <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://client.example.com/cb?
code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
&state=af0ifjsldkj]]></artwork>
            </figure>
          </section>

          <section anchor="authz_error"
                   title="End-User Denies Authorization or Invalid Request">
            <t>If the user denies the authorization or the user authentication
            fails, the authorization server MUST return the negative authorization 
            response as defined in <xref target="OpenID.Messages">OpenID Connect
            Messages 1.0</xref>. The authorization server returns the client
            the redirection URI specified in the authorization request
            with the appropriate error parameters in the HTTP query string. No
            other parameters SHOULD be returned.</t>

            <t><figure>
                <preamble>The following is a non-normative example. Line wraps
                after the second line is for the display purpose
                only:</preamble>

                <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://client.example.com/cb?
error=invalid_request
&error_description=the%20request%20is%20not%20valid%20or%20malformed
&state=af0ifjsldkj]]></artwork>
              </figure></t>
          </section>
        </section>

        <section title="Client Request Assertion Using the &quot;Code&quot;">
          <t>Upon receipt of the <spanx style="verb">"code"</spanx>, the
          Client requests an Assertion that includes the <spanx style="verb">"access_token"</spanx>
          and other variables. The requests and responses are described in the
          <xref target="token_ep">Token endpoint</xref> section.</t>
        </section>
      </section>

      <section anchor="implicit_flow" title="Implicit Flow">
        <t>The implicit grant flow follows the following steps:</t>

        <t><list style="numbers">
            <t>Client prepares an Authorization Request containing the desired
            request parameters.</t>

            <t>Client sends a request to the Authorization Server.</t>

            <t>Authorization Server Authenticates the End-User</t>

            <t>Authorization Server Obtains the End-User
            Consent/Authorization</t>

            <t>Authorization Server Sends the End-User back to the Client with
            an Access Token</t>
          </list></t>

        <section anchor="implicit_prep"
                 title="Client Prepares an Authorization Request URL ">
          <t>When the user wishes to access a Protected Resource, and the
          End-User Authorization has not yet been obtained, the Client
          prepares an Authorization Request URL using URI query string
          serialization as defined in <xref target="OpenID.Messages">OpenID
          Connect Messages 1.0</xref>.</t>

          <t>The scheme used in the Authorization URL MUST be HTTPS.</t>

          <t>This binding further constrains the following request
          parameters</t>

          <t><list style="hanging">
              <t hangText="response_type">It MUST include <spanx style="verb">token</spanx>
              and <spanx style="verb">id_token</spanx>.</t>
            </list></t>

          <t>The request MUST contain the other required parameters and MAY
          contain optional parameters as defined in the <xref
          target="rf_prep">preparing an authorization request</xref>
          section.</t>
        </section>

        <section anchor="implicit_req"
                 title="Client Sends a Request to the Authorization Server">
          <t>Having constructed the URL, the client sends the End-User to the
          HTTPS End-User Authorization Endpoint using the URL. This MAY happen
          via HTTPS redirect, hyperlinking, or any other means of directing
          the User-Agent to the URL.</t>

          <t>Following is a non-normative example using HTTP redirect. Note:
          Line wraps are for display purpose only.</t>

          <figure>
            <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://server.example.com/authorize?
response_type=token
&client_id=s6BhdRkqt3
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&state=af0ifjsldkj
]]></artwork>
          </figure>
        </section>

        <section title="Authorization Server Authenticates the End-User">
          <t>The Authorization Server validates the request to ensure all
          required parameters are present and valid. If the request is valid,
          the authorization server MUST authenticate the End-User. The way in
          which the authorization server authenticates the End-User (e.g.
          username and password login, session cookies) is beyond the scope of
          this specification. An authentication user interface MAY be displayed
          by the Authorization Server depending on the authentication method
          used.</t>

          <t>The Authorization Server MUST attempt to authenticate the 
          user in the following cases:
          <list style="symbols">
                <t>The End-User is not already authenticated by the Authorization
                Server.</t>

                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with a value "login". The
                Authorization Server MUST reauthenticate the user
                even if the user is already authenticated.</t>
          </list></t>
          <t>The Authorization Server MUST NOT attempt authentication
          in the following cases:
          <list style="symbols">
                <t>The Authorization Request contains the <spanx 
                style="verb">"display"</spanx> parameter with a value "none".
                The Authorization Server MUST return an error if the user is 
                unauthenticated.</t>
          </list></t>
        </section>

        <section title="Authorization Server Obtains the End-User Consent/Authorization">
          <t>Once the user is authenticated, the Authorization Server MUST
          obtain an authorization decision. This MAY be done by presenting the
          user with a dialogue that allows the user to recognize what he is
          consenting to and obtain his consent or by establishing approval via
          other means (for example, via previous administrative approval).</t>

          <t>The Authorization Server MUST attempt to request authorization
          from the user in the following cases:
          <list style="symbols">
                <t>The End-User has not pre-authorized the client for the
                authorization request.</t>

                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with a value "consent". The
                Authorization Server MUST request user authorization even if the
                user has previously authorized the client.</t>
          </list></t>
          <t>The Authorization Server MUST NOT request user authorization in the
          following cases:
          <list style="symbols">
                <t>The Authorization Request contains the <spanx 
                style="verb">"display"</spanx> parameter with a value "none".
                The Authorization Server MUST return an error if the user has
                not pre-authorized the client.</t>
          </list></t>
        </section>

        <section anchor="implicit_res"
                 title="Authorization Server Sends the End-User Back to the Client ">
          <t>Once the authorization is determined, the Authorization Server
          returns a positive or negative response.</t>

          <section anchor="implicit_ok" title="End-User Grants Authorization">
            <t>If the resource owner grants the access request, the
            authorization server issues an access token and delivers it to the
            client by adding the following parameters to the fragment
            component of the redirection URI using the
            "application/x-www-form-urlencoded" format:<list style="hanging">
                <t hangText="access_token">REQUIRED. The Access Token</t>

                <t hangText="token_type">REQUIRED. This specification only
                supports the <xref target="OAuth.2.0.Bearer">Bearer
                Token</xref> scheme. As such, this value MUST be set to
                "<spanx style="verb">Bearer</spanx>".</t>

                <t hangText="state">REQUIRED if the <spanx style="verb">"state"</spanx>
                parameter in the request. Set to the exact value of the <spanx
                style="verb">"state"</spanx> parameter received from the
                client.</t>

                <t hangText="id_token">REQUIRED if the <spanx style="verb">response_type</spanx>
                parameter in the request included the <spanx style="verb">id_token</spanx>
                value.</t>
              </list></t>

            <t>The client can then use the Access Token to access protected
            resources at resource servers.</t>

            <figure>
              <preamble>The following is a non-normative example. Line wraps
              after the second line is for the display purpose
              only:</preamble>

              <artwork><![CDATA[HTTP/1.1 302 Found
Location: https://client.example.com/cb#
access_token=SlAV32hkKG&
token_type=Bearer&
expires_in=3600&
&state=af0ifjsldkj
&id_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9zZXJ2ZXIuZXhhbXBsZS5jb20iLCJ1c2VyX2lkIjoiMj
Q4Mjg5NzYxMDAxIiwiYXVkIjoiaHR0cDpcL1wvY2xpZW50LmV4YW1wbGUuY29tIiwiZXhwIjoxMzExMjgxOTcwfQ.eDesUD0vzDH3T1G3liaTNOrf
aeWYjuRCEPNXVtaazNQ
]]></artwork>
            </figure>
          </section>

          <section anchor="implicit_authz_error"
                   title="End-User Denies Authorization or Invalid Request">
            <t>If the user denies the authorization or the user authentication
            fails, the authorization server MUST return the negative
            authorization response as defined in <xref 
            target="OpenID.Messages">OpenID Connect Messages 1.0</xref>.
            No other parameter SHOULD be returned.</t>
          </section>
        </section>
      </section>
    </section>

    <section anchor="token_ep" title="Token Endpoint">
      <t>The Token endpoint handles requests for retrieving and refreshing
      access tokens.</t>

      <t>Clients MUST use the HTTP "POST" method to make requests to the Token
      endpoint. Request parameters are added to the HTTP request entity-body
      using the <spanx style="verb">application/x-www-form-urlencoded</spanx>
      format.</t>

      <t>Clients MAY provide authentication parameters in the request to the
      Token endpoint as described in section 3.2 of <xref
      target="OpenID.Messages">OpenID Connect Messages</xref> and section
      3.2.1 of <xref target="OAuth.2.0">OAuth 2.0</xref>.</t>

      <t>Authorization servers MUST require the use of a transport-layer
      security mechanism. The authorization server MUST support TLS 1.2 as
      described in <xref target="RFC5246">RFC 5246</xref> and MAY support
      other transport-layer mechanisms with equivalent security.</t>

      <t>All Token endpoint responses that contain tokens, secrets, or other
      sensitive information MUST include the following HTTP response header
      fields and values:</t>

      <t></t>

      <texttable title="HTTP Response Headers and Values">
        <ttcol>Header Name</ttcol>

        <ttcol>Header Value</ttcol>

        <c>Cache-Control</c>

        <c>no-store</c>

        <c>Pragma</c>

        <c>no-cache</c>
      </texttable>

      <t></t>

      <section title="Requesting an Access Token">
        <t>To retrieve an access token, a client MUST have an authorization
        code obtained via the method as described in <xref
        target="code_flow">Authorization Code Flow</xref>.</t>

        <section title="Access Token Request">
          <t>To obtain a access token assertion, the client MUST send the
          following parameters via HTTPS POST to the Token endpoint using
          <spanx style="verb">application/x-www-form-urlencoded</spanx> format
          in the HTTP request entity-body as specified in Section 4.1.3 of 
      <xref target="OAuth.2.0">OAuth 2.0</xref>:</t>

          <t><list style="hanging">
              <t hangText="grant_type">REQUIRED. A string "<spanx
              style="verb">authorization_code</spanx>".</t>

              <t hangText="code">REQUIRED. The authorization code received
              from the authorization server.</t>
        
        <t hangText="redirect_uri">REQUIRED, if the 
        <spanx style='verb'>redirect_uri</spanx>  
        parameter was included in the authorization request described 
        in Section 4.1.1 of <xref target="OAuth.2.0">OAuth 2.0</xref>, 
        and their values MUST be identical.</t>
        
            </list></t>

          <t> If the client type is confidential or was issued client credentials
      (or assigned other authentication requirements), the client MUST
      authenticate with the authorization server as described in 
      Section 3.2.1 of <xref target="OAuth.2.0">OAuth 2.0</xref>.</t>

          <figure>
            <preamble>The following is a non-normative example. Line wraps
            after line 4 are for display purpose only:</preamble>

            <artwork><![CDATA[POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded;charset=UTF-8

grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
]]></artwork>
          </figure>
          <t>
            The authorization server MUST:
          </t>
          <t>
            <list style='symbols'>
              <t>
                require client authentication for confidential clients or for any client issued
                client credentials (or with other authentication requirements),
              </t>
              <t>
                authenticate the client if client authentication is included and ensure the
                authorization code was issued to the authenticated client,
              </t>
              <t>
                verify that the authorization code is valid, and
              </t>
              <t>
                ensure that the <spanx style='verb'>redirect_uri</spanx> parameter is present if
                the <spanx style='verb'>redirect_uri</spanx> parameter was included in the initial
                authorization request described in <xref target='code-authz-req' />, and that their
                values are identical.
              </t>
            </list>
          </t>
        </section>

        <section title="Access Token Response">
          <t>Upon receipt of the Token Request, the Authorization Server MUST
          return either Positive or Negative Assertion that corresponds to the 
          received authorization code.</t>

          <section title="Positive Assertion">
            <t>A Positive Assertion response returns the "<spanx style="verb">application/json</spanx>"
            media type and the response body is the Access Token Response of
            the <xref target="OpenID.Messages">OpenID Connect Messages
            1.0</xref>.</t>

            <t>The assertion is a JSON structure which MUST contain the
            following values:</t>

            <t><list style="hanging">
                <t hangText="access_token">The access token.</t>

                <t hangText="id_token">The ID Token associated with the
                authentication session.</t>

                <t hangText="token_type">Specifies the access token type. This
                specification only support the "Bearer" token type.</t>
              </list> In addition, it can contain the optional <spanx
            style="verb">refresh_token</spanx>, <spanx style="verb">expires_in</spanx>,
            and <spanx style="verb">scope</spanx> values.</t>

            <figure>
              <preamble>Following is a non-normative example of the Positive
              Assertion:</preamble>

              <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
    "access_token": "SlAV32hkKG",
    "token_type": "Bearer",
    "refresh_token": "8xLOxBtZp8",
    "expires_in": 3600,
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9zZXJ2ZXIuZXhhbXBsZS5jb20iLCJ1c2VyX2lkIjoiMj
Q4Mjg5NzYxMDAxIiwiYXVkIjoiaHR0cDpcL1wvY2xpZW50LmV4YW1wbGUuY29tIiwiZXhwIjoxMzExMjgxOTcwfQ.eDesUD0vzDH3T1G3liaTNOrfaeWYjuR
CEPNXVtaazNQ"
}]]></artwork>
            </figure>
          </section>

          <section title="Error Response">
            <t>If the Token Request is invalid or unauthorized, the
            Authorization Server constructs the response by returning the
            Token Error Response defined in <xref
            target="OpenID.Messages">OpenID Connect Messages 1.0</xref> in the
            entity body of the HTTP response using the <spanx style="verb">application/json</spanx>
            media type with HTTP response code 400.</t>

            <figure>
              <preamble>Following is a non-normative example:</preamble>

              <artwork><![CDATA[HTTP/1.1 400 Bad Request
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
  "error":"invalid_request"
}]]></artwork>
            </figure>
          </section>
        </section>
      </section>

      <section title="Refreshing an Access Token">
        <t>To refresh an Access token that has expired, the client sends a
        POST request to the Token endpoint with the following parameters in
        the entity-body using the application/x-www-form-urlencoded
        format:</t>

        <t><list style="hanging">
            <t hangText="grant_type">REQUIRED. A string "refresh_token".</t>

            <t hangText="refresh_token">REQUIRED. The refresh token that was
            issued in a previous Token endpoint request.</t>

            <t hangText="scope">REQUIRED. It MUST include <spanx style="verb">openid</spanx>
            as one of the strings. Other values that MAY be included are
            <spanx style="verb">profile</spanx>, <spanx style="verb">email</spanx>,
            <spanx style="verb">address</spanx>, and <spanx style="verb">PPID</spanx>.
            The values specify an additive list of claims that are returned by
            the UserInfo endpoint.</t>
          </list>The authorization MUST verify the validity of the refresh
        token</t>

        <section title="Positive Assertion">
          <t>Upon successful verification of the refresh token, a positive
          assertion response returns the "<spanx style="verb">application/json</spanx>"
          media type and the response body is the Access Token Response of the
          <xref target="OpenID.Messages">OpenID Connect Messages
          1.0</xref>.</t>

          <t>The assertion is a JSON structure which MUST contain the
          following values:</t>

          <t><list style="hanging">
              <t hangText="access_token">The access token.</t>

              <t hangText="id_token">The ID Token associated with the
              authentication session.</t>

              <t hangText="token_type">Specifies the access token type. This
              specification defines the "JWT" type for a JWT token.</t>
            </list> In addition, it can contain the optional <spanx
          style="verb">refresh_token</spanx>, <spanx style="verb">expires_in</spanx>,
          and <spanx style="verb">scope</spanx> values.</t>

          <figure>
            <preamble>Following is a non-normative example of the refresh
            token request and response:</preamble>

            <artwork><![CDATA[POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

client_id=s6BhdRkqt3
&client_secret=some_secret12345
&grant_type=refresh_token
&refresh_token=8xLOxBtZp8
&scope=openid


HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

{
    "access_token": "TlBN45jURg",
    "token_type": "Bearer",
    "refresh_token": "9yNOxJtZa5",
    "expires_in": 3600,
    "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9zZXJ2ZXIuZXhhbXBsZS5jb20iLCJ1c2VyX2lkIjoiMj
Q4Mjg5NzYxMDAxIiwiYXVkIjoiaHR0cDpcL1wvY2xpZW50LmV4YW1wbGUuY29tIiwiZXhwIjoxMzExMjgxOTcwfQ.eDesUD0vzDH3T1G3liaTNOrfaeWYjuR
CEPNXVtaazNQ"
}]]></artwork>
          </figure>
        </section>
      </section>
    </section>

    <section anchor="userinfo_ep" title="UserInfo Endpoint">
      <t>To obtain the additional attributes and tokens/assertions, the client
      makes a GET or POST request to the UserInfo Endpoint as in <xref
      target="OpenID.Messages">OpenID Connect Messages 1.0</xref>.</t>

      <t>Authorization servers MUST require the use of a transport-layer
      security mechanism. The authorization server MUST support TLS 1.2 as
      described in <xref target="RFC5246">RFC 5246</xref> and MAY support
      other transport-layer mechanisms with equivalent security.</t>

      <section title="UserInfo Request">
        <t>Client SHOULD send the UserInfo request defined in section 3.3 of
        the <xref target="OpenID.Messages">OpenID Connect Messages 1.0</xref>
        either in HTTP GET or POST request.</t>

        <t>The request parameters are the following:</t>

        <t><list style="hanging">
            <t hangText="access_token">REQUIRED. The access_token obtained
            from an OpenID Connect authorization request. This parameter MUST
            NOT be sent if the access token is sent in the HTTP Authorization
            header as described in Section 7.1 of <xref
            target="OAuth.2.0">OAuth 2.0</xref>. Access tokens sent in the
            authorization header must be <xref
            target="OAuth.2.0.Bearer">Bearer tokens</xref>. If the client is
            using the HTTP GET method, it SHOULD send the access token in the
            authorization header. </t>

            <t hangText="schema">OPTIONAL. The schema in which the data is to
            be returned. The only predefined value is <spanx style="verb">openid</spanx>.
            If this parameter is not included, the response may be a
            proprietary schema to support backwards compatibility. A URL MAY
            be passed to define custom schemes not specified by short names.
            Custom scheme names and responses are out of scope for this
            specification.</t>

            <t hangText="id">This identifier is reserved for backwards
            compatibility. It MUST be ignored by the endpoint if the <spanx
            style="verb">openid</spanx> schema is used.</t>
          </list></t>

        <figure>
          <preamble>The following is a non-normative example. Line wraps are
          for display purpose only:</preamble>

          <artwork><![CDATA[POST /userinfo HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

access_token=SlAV32hkKG]]></artwork>
        </figure>
      </section>

      <section anchor="id_res" title="UserInfo Response">
        <t>Upon receipt of the UserInfo request, the UserInfo endpoint MUST
        return the JSON Serialization of the UserInfo response as in <xref
        target="OpenID.Messages">OpenID Messages</xref> in the HTTP response
        body. The content-type of the HTTP response MUST be set to <spanx
        style="verb">application/json</spanx> if the response body is a text
        JSON structure. If the JSON response is <xref target="JWS">JWS</xref>
        signed or <xref target="JWE">JWE</xref> encrypted, then the
        content-type MUST be set to <spanx style="verb">application/jwt</spanx>.</t>

        <figure>
          <preamble>Following is a non-normative example of such
          response:</preamble>

          <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json

{
 "name": "Jane Doe"
 "given_name": "Jane",
 "family_name": "Doe",
 "email": "janedoe@example.com",
 "picture": "http://example.com/janedoe/me.jpg"
}]]></artwork>
        </figure>

        <section title="UserInfo Error Response">
          <t>When some error condition arises, the UserInfo endpoint returns
          the JSON serialized Error Response defined in section 3.3.3 of <xref
          target="OpenID.Messages">OpenID Connect Messages 1.0</xref> in the
          entity body of the HTTP response using the <spanx style="verb">application/json</spanx>
          media type with HTTP response code 400.</t>

          <t><figure>
              <preamble>Following is a non-normative example of an error
              response:</preamble>

              <artwork><![CDATA[HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error":"invalid_request"
}
]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section anchor="checkid_ep" title="Check ID Endpoint">
      <t>The Check ID endpoint validates ID Tokens and returns the claims
      of an issued ID Token in JSON text format. This endpoint is used by
      clients that are not able to or do not wish to process ID Tokens.
      Clients MAY treat ID Tokens as opaque values and use the Check ID
      endpoint to validate and retrieve the claims associated with the ID
      Token in plain text JSON format.</t>

      <section title="Client ID Requests">
        <t>Clients MUST make a HTTP POST request using transport-layer
        security with the following <spanx style="verb">application/x-www-form-urlencoded</spanx>
        parameters in the request body:</t>

        <t><list style="hanging">
            <t hangText="id_token">REQUIRED. The ID Token obtained from an
            OpenID Connect authorization request.</t>
          </list><figure>
            <preamble>The Following is a non-normative example of an Check
            ID request:</preamble>

            <artwork><![CDATA[POST /check_id HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

id_token=OjkdKlsdHV3JdsZmP
]]></artwork>
          </figure></t>
      </section>

      <section anchor="intro_res" title="Check ID Response">
        <t>The Check ID Endpoint MUST return the JSON serialized claims
        associated with the ID Token as described in Check ID Response
        section of <xref target="OpenID.Messages">OpenID Messages</xref> in
        the HTTP response body. The content-type of the HTTP response MUST be
        set to <spanx style="verb">application/json</spanx> if the response
        body is a text JSON structure. If the JSON response is <xref
        target="JWS">JWS</xref> signed or <xref target="JWE">JWE</xref>
        encrypted, then the content-type MUST be set to <spanx style="verb">application/jwt</spanx>.</t>

        <figure>
          <preamble>The following is a non-normative example of a response
          from the Check ID endpoint:</preamble>

          <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json

{
 "iss": "http://server.example.com",
 "user_id": "248289761001",
 "aud": "http://client.example.com",
 "exp": 1311281970
}
]]></artwork>
        </figure>

        <section title="Check ID Error Response">
          <t>When some error condition arises, the UserInfo endpoint returns
          the JSON serialized Error Response defined in section 3.4.3 of <xref
          target="OpenID.Messages">OpenID Connect Messages 1.0</xref> in the
          entity body of the HTTP response using the <spanx style="verb">application/json</spanx>
          media type with HTTP response code 400.</t>

          <t><figure>
              <preamble>Following is a non-normative example of an error
              response:</preamble>

              <artwork><![CDATA[HTTP/1.1 400 Bad Request
Content-Type: application/json

{
  "error":"invalid_id_token"
}
]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section anchor="session_eps" title="Session Management Endpoints">
      <t>The Session Management endpoints are specified in the <xref
      target="OpenID.Session">OpenID Connect Session Management</xref>
      specification.</t>
    </section>

    <section anchor="disco_reg" title="Discovery and Registration">
      <t>Some OpenID Connect installations can use a pre-configured set of
      OpenID Providers and/or Relying Parties. In those cases, it may not be
      necessary to support dynamic discovery of information about identities
      or services or dynamic registration of clients.</t>

      <t>However, if installations choose to support unanticipated
      interactions between Relying Parties and OpenID Providers that do not
      have pre-configured relationships, they SHOULD accomplish this by
      implementing the facilities defined in the <xref
      target="OpenID.Discovery">OpenID Connect Discovery 1.0</xref> and <xref
      target="OpenID.Registration">OpenID Connect Dynamic Client Registration
      1.0</xref> specifications.</t>
    </section>

    <section anchor="security_considerations" title="Security Considerations">
      <t>This specification references the security considerations defined in
      <xref target="OpenID.Messages">OpenID Connect Messages 1.0</xref>.</t>

      <t>In addition, the following list of attack vectors and remedies are
      also considered.</t>

      <section title="Implicit Grant Flow Threats">
        <t>In the implicit grant flow, the access token is returned in the
        fragment part of the client's redirect_uri through HTTPS, thus it is
        protected between the OP and the User-Agent, and User-Agent and the
        RP. The only the place it can be captured is the User-Agent where the
        TLS session is terminated, and is possible if the User-Agent is
        infested by malware.</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document makes no request of IANA.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119"?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616"?>

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246"?>

      <reference anchor="JWT">
        <front>
          <title>JSON Web Token</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
            <organization abbrev="goog">Google</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="pgs">rotivity Government
            Service</organization>
          </author>

          <author fullname="Yaron Goland" initials="Y." surname="Goland">
            <organization abbrev="msft">Microsoft</organization>
          </author>

          <author fullname="John Panzer" initials="J." surname="Panzer">
            <organization abbrev="goog">Google</organization>
          </author>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="nri">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
            <organization abbrev="fb">Facebook</organization>
          </author>

          <date day="11" month="July" year="2011" />
        </front>

        <format target="http://tools.ietf.org/html/draft-jones-json-web-token"
                type="HTML" />
      </reference>

      <reference anchor="JWS">
        <front>
          <title>JSON Web Signatures</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="Dirk Balfanz" initials="D." surname="Balfanz">
            <organization abbrev="goog">Google</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="pgs">rotivity Government
            Service</organization>
          </author>

          <author fullname="Yaron Goland" initials="Y." surname="Goland">
            <organization abbrev="msft">Microsoft</organization>
          </author>

          <author fullname="John Panzer" initials="J." surname="Panzer">
            <organization abbrev="goog">Google</organization>
          </author>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="nri">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
            <organization abbrev="fb">Facebook</organization>
          </author>

          <date day="29" month="April" year="2011" />
        </front>

        <format target="http://tools.ietf.org/html/draft-jones-json-web-signature"
                type="HTML" />
      </reference>

      <reference anchor="JWE">
        <front>
          <title>JSON Web Encryption</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="pgs">rotivity Government
            Service</organization>
          </author>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="nri">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <date day="23" month="July" year="2011" />
        </front>

        <format target="http://self-issued.info/docs/draft-jones-json-web-encryption.html"
                type="HTML" />
      </reference>

      <reference anchor="OpenID.Messages">
        <front>
          <title>OpenID Connect Messages 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute,
            Ltd.</organization>
          </author>

    <author fullname="David Recordon" initials="D." surname="Recordon">
      <organization abbrev="Facebook">Facebook</organization>
    </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Protiviti">Protiviti Government
            Services</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B."
                  surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="MGI1">MGI1</organization>
          </author>

          <date day="2" month="September" year="2011" />
        </front>

        <format target="http://openid.net/specs/openid-connect-messages-1_0.html"
                type="HTML" />
      </reference>

      <reference anchor="OpenID.Registration">
        <front>
          <title abbrev="Abbreviated-Title">OpenID Connect Dynamic Client
          Registration 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." role="editor"
                  surname="Bradley">
            <organization abbrev="Protiviti">Protiviti Government
            Services</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <date day="2" month="September" year="2011" />
        </front>

        <format target="http://openid.net/specs/openid-connect-registration-1_0.html"
                type="HTML" />
      </reference>

      <reference anchor="OpenID.Discovery">
        <front>
          <title>OpenID Connect Discovery 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Protiviti">Protiviti Government
            Services</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="MGI1">MGI1</organization>
          </author>

          <date day="2" month="September" year="2011" />
        </front>

        <format target="http://openid.net/specs/openid-connect-discovery-1_0.html"
                type="HTML" />
      </reference>

      <reference anchor="OpenID.Session">
        <front>
          <title abbrev="Abbreviated-Title">OpenID Connect Session Management
          1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute,
            Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Protiviti">Protiviti Government
            Services</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B."
                  surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

          <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
            <organization abbrev="Salesforce">Salesforce</organization>
          </author>

          <author fullname="Edmund Jay" initials="E." surname="Jay">
            <organization abbrev="MGI1">MGI1</organization>
          </author>

          <date day="2" month="September" year="2011" />
        </front>

        <format target="http://openid.net/specs/openid-connect-session-1_0.html"
                type="HTML" />
      </reference>

      <reference anchor="OAuth.2.0">
        <front>
          <title>OAuth 2.0 Authorization Protocol</title>

          <author fullname="Eran Hammer-Lahav" initials="E." role="editor"
                  surname="Hammer-Lahav">
            <organization abbrev="Yahoo">Yahoo</organization>
          </author>

          <author fullname="David Recordon" initials="D." surname="Recordon">
            <organization abbrev="Facebook">Facebook</organization>
          </author>

          <author fullname="Dick Hardt" initials="D." surname="Hardt">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <date day="25" month="July" year="2011" />
        </front>

        <format target="http://tools.ietf.org/html/draft-ietf-oauth-v2"
                type="HTML" />
      </reference>

      <reference anchor="OAuth.2.0.Bearer">
        <front>
          <title>OAuth 2.0 Protocol: Bearer Tokens</title>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft
            Corporation</organization>
          </author>

          <author fullname="Dick Hardt" initials="D." surname="Hardt">
            <organization>Independent</organization>
          </author>

          <author fullname="David Recordon" initials="D." surname="Recordon">
            <organization abbrev="Facebook">Facebook</organization>
          </author>

          <date day="27" month="July" year="2011" />
        </front>

        <format target="http://tools.ietf.org/html/draft-ietf-oauth-v2-bearer"
                type="HTML" />
      </reference>
    </references>

    <!-- <references title="Informative References"> -->

    <!-- </references> -->

    <section title="Footnotes">
      <t></t>

      <section title="Example JWT Values">
        <t>The JWT values used in the non-normative examples of this
        specification are only place holders for actual JWT values. The
        examples use "jwt_header.jwt_part2.jwt_part3" as the place holder
        value. For an example of an actual JWT, refer to the <xref
        target="JWT">JWT</xref> specification.</t>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>The OpenID Community would like to thank the following people for the
      work they've done in the drafting and editing of this specification.</t>

      <t><list style="empty">
          <t>Axel Nennker (axel.nennker@telekom.de), Deutsche Telekom</t>

          <t>Breno de Medeiros (breno@gmail.com), Google</t>

          <t>George Fletcher (gffletch@aol.com), AOL</t>

          <t>Hideki Nara (hideki.nara@gmail.com), Takt Communications</t>

          <t>John Bradley (jbradely@mac.com), Protiviti Government
          Services</t>

          <t>Nat Sakimura (n-sakimura@nri.co.jp)), Nomura Research Institute,
          Ltd.</t>

          <t>Michael B. Jones (mbj@microsoft.com), Microsoft</t>

          <t>Ryo Itou (ritou@yahoo-corp.jp), Yahoo! Japan</t>
        </list></t>
    </section>

    <section title="Document History">
      <t>[[ To be removed from the final specification ]]</t>

      <t>-04 <list style="symbols">
          <t>Changes associated with renaming "Lite" to "Basic Client"
          and replacing "Core" and "Framework" with "Messages" and
          "Standard".</t>

          <t>Numerous cleanups, including updating references.</t>
        </list></t>

      <t>-03 <list style="symbols">
          <t>Added secret_type to the Token endpoint.</t>

          <t>Minor edits to the samples.</t>
        </list></t>

      <t>-02 <list style="symbols">
          <t>Incorporates feedback from Nat Sakimura.</t>
        </list></t>

      <t>-01 <list style="symbols">
          <t>First Draft that incorporates the merge of the Core and Framework
          specs.</t>
        </list></t>
    </section>
  </back>
</rfc>
